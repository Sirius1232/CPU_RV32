# CPU-RV32

<!--基于FPGA的32位RISC-V架构五级流水线CPU设计-->

## 一、流水线结构

本设计使用经典的五级流水线结构，即：取指、译码、执行、访存、写回。

- 取指：包括**指令计数器`pc`生成**和**简单分支预测**
- 译码：根据指令编码规则拆分指令，并判断指令类型，给出相应的运行控制信号
- 执行：只对输入数据做算数/逻辑运算，不做其他处理
- 访存：实现对数据存储器的读写控制，以及数据长度控制
- 写回：将执行/访存的结果写入寄存器

<img src="D:\Typora\img\CPU-RV32\pipeline.svg" alt="pipeline" style="zoom:80%;" />



## 二、分支预测与流水线冲刷

### 1. 静态分支预测

本设计使用简单的静态分支预测，向前跳转（pc减小）预测为跳，向后跳转预测为不跳。

### 2. 流水线冲刷

在分支指令完成`执行`后，得到分支指令是否需要跳转的结果，若与`取指`时的预测结果不一致（即**分支预测错误**），则需要冲刷流水线。

由下图可知，当分支指令完成`执行`后进入了`访存`阶段，此时在该分支下已经取出了两条指令，分别处于`执行`和`译码`两个阶段，冲刷流水线时需要将这两个模块的输出置零；而`取指`模块只需要将当前的`pc`值设置为分支预测时保存的另一种分支情况的`pc`值即可。

<img src="D:\Typora\img\CPU-RV32\flush.svg" alt="flush" style="zoom:80%;" />



## 三、数据冲突处理

### 1. 数据冲突问题分析

由于本设计架构属于“**顺序发射、顺序执行、顺序写回**”，因此，本设计中只存在**RAW**（Read-After-Write，先写后读）相关性的数据冲突问题。RAW相关性是由后续指令需要读取的源操作数寄存器与前序指令需要写回的结果寄存器一致所导致的，简单来说就是，前序指令会改变寄存器`xn`的值，但还没有写回，此时后续就需要读取`xn`的值，导致数据冲突。

解决方法：

1. 寄存器`xn`的新数据已经计算（执行/访存）完成但还没有写回，此时可以**提前将结果送回**需要用到该数据的地方；
2. 寄存器`xn`的新数据尚未完成计算，此时就需要**暂停前序流水线**，等待计算完成。

下面将分别说明流水线各级可能出现的RAW相关性冲突及其解决方法。为了方便描述，这里对一些用语设置了统一的规范：

1. 将处于流水线各个阶段的指令依次使用`n`到`n-3`来编号（取指阶段尚未取出指令，不需要编号），如下图所示；
2. 由于部分信号需要在后续流水线中使用（如`译码`阶段的输出等），所以在编写的程序时，一些需要锁存的信号统一规范编码，以其所处于的流水线阶段为命名开头（如传递到`访存`阶段的信号统一以`stp2_`开头）

<img src="D:\Typora\img\CPU-RV32\data_conflict.svg" alt="DataConflict" style="zoom:80%;" />

### 2. 访存的数据冲突问题

访存指令（`load`和`store`两类）有两个需要读取寄存器的地方，一是访存地址通过“寄存器值+偏移”的方法来获取；二是待写入存储器的数据需要从寄存器中读取。其中，访存地址的运算在`执行`阶段完成，其数据冲突问题放在下一小节中说明；`访存`阶段只需要处理第二个冲突问题。

当指令`n-2`为访存指令时，只存在一种数据冲突的可能，即指令`n-3`的结果寄存器与`n-2`的源寄存器相同，因此，只需要将`写回`阶段需要写入寄存器的数据作为`n-2`的源寄存器的数据即可。

> 访存还存在一个数据冲突的可能，指令n译码时，获取了寄存器数据，但指令n-2在下一个时钟周期修改了该寄存器的值，导致数据不匹配

```verilog
/*访存阶段的数据冲突问题*/
always @(*) begin
    if(stp2_rs2==5'd0)  // 与寄存器值无关
        ram_din = 32'd0;
    else if(stp2_rs2==stp3_rd)
        ram_din = stp3_data_rd;
    else
        ram_din = stp2_data2;
end
```

### 3. 执行的数据冲突问题

执行模块有两个数据输入，都可能出现数据冲突，需要分别独立判断，下面以一个输入为例。

处于`执行`阶段的指令为`n-1`，而上一时刻`执行`和`访存`的输出（即当前时刻的指令`n-2`和`n-3`）都可能影响寄存器的数据。对于指令`n-3`导致的冲突，与前述访存的冲突是一样的，这里不再重复；而指令`n-2`导致的冲突又需要分为两种情况来讨论：

1. `n-2`为读数据存储器指令`load`：这类指令在`访存`阶段结束才能得到最后的结果，由此造成的数据冲突无法直接解决，需要等待`n-2`完成`访存`阶段取出数据，因此，需要将`取指`、`译码`、`执行`同时**暂停一次**，即**锁存取指和译码所有信号，并将执行的输出清零**；
2. `n-2`为除了`load`以外的其他指令：这些指令要么不影响寄存器，要么在`执行`阶段就能够得到最终结果，因此，如果发生数据冲突同样可以提前引出结果数据加入计算。

```verilog
/*执行阶段的数据冲突问题*/
/*判断是否需要暂停流水线以等待数据*/
assign  wait_exe = wait_exe_1 | wait_exe_2;
always @(*) begin
    if(stp1_rs1==5'd0 || imm_en[1] || jmp_ctrl[1])  // 与寄存器值无关
        wait_exe_1 = 1'b0;
    else if(stp1_rs1==stp2_rd && load_flg_seq[2])  // 执行
        wait_exe_1 = 1'b1;
    else if(stp1_rs1==stp3_rd)  // 访存
        wait_exe_1 = 1'b0;
    else
        wait_exe_1 = 1'b0;
end
always @(*) begin
    if(stp1_rs2==5'd0 || imm_en[0] || jmp_ctrl[1])  // 与寄存器值无关
        wait_exe_2 = 1'b0;
    else if(stp1_rs2==stp2_rd && load_flg_seq[2])  // 执行
        wait_exe_2 = 1'b1;
    else if(stp1_rs2==stp3_rd)  // 访存
        wait_exe_2 = 1'b0;
    else
        wait_exe_2 = 1'b0;
end
/*提前引出数据*/
always @(*) begin
    if(stp1_rs1==5'd0 || imm_en[1] || jmp_ctrl[1])  // 与寄存器值无关
        data1 = 32'd0;
    else if(stp1_rs1==stp2_rd)  // 执行的输出
        data1 = stp2_exu_out;
    else if(stp1_rs1==stp3_rd)  // 访存的输出
        data1 = stp3_data_rd;
    else
        data1 = stp1_data1;
end
always @(*) begin
    if(stp1_rs2==5'd0 || imm_en[0])  // 与寄存器值无关
        data2 = 32'd0;
    else if(stp1_rs2==stp2_rd)  // 执行的输出
        data2 = stp2_exu_out;
    else if(stp1_rs2==stp3_rd)  // 访存的输出
        data2 = stp3_data_rd;
    else
        data2 = stp1_data2;
end
```

### 4. 取指的数据冲突问题

取指阶段会用到寄存器数据的只有指令`n`为`jalr`这一种可能，此时需要分三种情况来讨论：

1. 指令`n-1`导致的冲突：如果`n-1`是一个会影响寄存器数据的指令，并且其结果寄存器与指令`n`的源寄存器一致，则会产生冲突，并且只能**暂停取指**，即**锁存取指模块的内部信号，并输出空指令`nop`以推动后续流水线运行**；
2. 指令`n-2`导致的冲突：该情况与上一小节中的描述一样，只有`n-2`为`load`指令时才会产生冲突，解决方法也一样；
3. 指令`n-3`导致的冲突：该情况与前述访存的冲突是一样的，这里同样不再重复。

```verilog
/*取指阶段的数据冲突问题*/
always @(*) begin
    if(!jmp_reg_en || jmp_rs==5'd0)  // 非寄存器链接或链接到x0
        wait_jmp = 1'b0;
    else if(jmp_rs==stp1_rd && stp1_wr_en)
        wait_jmp = 1'b1;
    else if(jmp_rs==stp2_rd && load_flg_seq[2])
        wait_jmp = 1'b1;
    else
        wait_jmp = 1'b0;
end
always @(*) begin
    if(jmp_rs==5'd0)
        jmp_data = 32'd0;
    else if(jmp_rs==stp2_rd)
        jmp_data = stp2_exu_out;
    else if(jmp_rs==stp3_rd)
        jmp_data = stp3_data_rd;
    else
        jmp_data = jmp_data_rs;
end
```

### 5. 一些特判

RISC-V架构的通用寄存器`x0`为硬件零，因此，若源操作数寄存器为`x0`就不需要考虑数据冲突。

`执行`模块的输入可以是寄存器的数据，也可以是立即数；如果输入是立即数的话也不需要考虑数据冲突。

### 6. 优先级问题

流水线冲刷、执行阶段数据冲突、取指阶段数据冲突都会打断流水线的正常连续运行，但影响方式和范围是不同的，如果有两种以上的情况同时出现，需要根据优先级来执行相应的改变。

- **流水线冲刷**是在分支预测错误时发生的，这一情况说明前序若干条指令均为错误取指的指令，需要直接清除，因此，其优先级最高；
- **执行阶段数据冲突**和**取指阶段数据冲突**都会造成流水线的部分环节暂停，而前者造成的暂停范围包括了后者，因此，执行阶段数据冲突的优先级更高；
- 综上，优先级顺序为**流水线冲刷>执行阶段数据冲突>取指阶段数据**。

由于三者具有严格的优先级次序，所有可能被影响的信号都**必须严格按照优先级次序**来做出相应的改变！





